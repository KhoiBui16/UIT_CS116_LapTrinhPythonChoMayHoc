# -*- coding: utf-8 -*-
"""numpy-matplotlib-pandas-tutorial.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1tcozQVFIOs6lRsO3nz0uk3ygcYcu299X

# PHẦN 1: LẬP TRÌNH VỚI NUMPY

## 0. Giới thiệu

Numpy là một thư viện tính toán khoa học, hiệu năng cao và rất phổ biến cho ngôn ngữ lập trình Python. Thư viện thực hiện trên các đối tượng toán học đa chiều như vector, ma trận, tensor...

Để sử dụng, ta cần phải khai báo thư viện `numpy`. Theo quy ước, thư viện này thường được viết tắt bằng `np`. Do đó, khi ta muốn sử dụng các module hay hàm nào đó của thư viện, ta chỉ việc thực hiện `np.`
"""

import numpy as np

"""### 1. Array và khởi tạo array

Numpy array là một cấu trúc các giá trị có cùng kiểu dữ liệu, được đánh chỉ mục bởi các số nguyên không âm.

Mỗi array sẽ có số chiều (``dimension``), tương ứng là hạng (``rank``) của array. Với mỗi chiều có kích thước (``shape``) từng chiều.

Để tạo `numpy` array, ta truyền một list vào `np.array()`. Ví dụ:
"""

a = np.array([1, 2, 3])  # Tạo array 1 chiều
print(a)

"""![](http://jalammar.github.io/images/numpy/create-numpy-array-1.png)"""

print('Kieu du lieu cua "a" la: ', type(a))

print('Kich thuoc theo tung chieu (dimension) cua "a": ', a.shape)

print('Truy xuat den 3 phan tu dau tien: ', a[0], a[1], a[2])
a[0] = 5                 # Thay đổi giá trị một phần tử trong array
print('Array "a" sau khi đã cập nhật phần tử đầu tiên: ', a)

"""Để tạo `numpy` array với nhiều hơn 1 chiều, ta truyền vào một list lồng nhau giống như sau:

![](http://jalammar.github.io/images/numpy/numpy-array-create-2d.png)

![](http://jalammar.github.io/images/numpy/numpy-3d-array.png)
"""

b = np.array([[1,2],[3,4]])   # Tạo array 2 chiều
print(b)

print(b.shape)

c = np.array([[[1,2],[3,4]],
              [[5,6],[7,8]] ])   # Tạo array 2 chiều
print(c)

c.shape

"""Trong một số trường hợp, ta muốn tạo array với giá trị khởi tạo sẵn. ``numpy`` cung cấp các phương thức như `ones()`, `zeros()`, và `random.random()` cho những tình huống này. Ta chỉ việc truyền vào số phần tử của array muốn khởi tạo:

![](http://jalammar.github.io/images/numpy/create-numpy-array-ones-zeros-random.png)

Trường hợp muốn khởi tạo array nhiều chiều, ta cũng truyền vào một ``tuple`` mô tả kích thước từng chiều:

![](http://jalammar.github.io/images/numpy/numpy-matrix-ones-zeros-random.png)

![](http://jalammar.github.io/images/numpy/numpy-3d-array-creation.png)
"""

a = np.zeros((2,2))  # tạo array gồm toàn số 0
print(a)

b = np.ones((1,2))   # tạo array gồm toàn số 1
print(b)

c = np.full((2,2), 7) # tạo array gồm toàn hằng số
print(c)

c = np.ones((2,2))*7  # tạo array gồm toàn số 1
print(c)

d = np.eye(4)        # Tạo ma trận đơn vị 2x2
print(d)

e = np.random.random((2,2)) # Tạo ma trận ngẫu nhiên
print(e)

"""Cuối cùng là 2 hàm rất hiệu quả và dùng phổ biến khác để khởi tạo giá trị theo dạng chuỗi số / dãy số là: ``arange`` và ``linspace``.

Hàm ``arange`` của ``numpy`` có cùng cú pháp với hàm ``range`` của Python: giá trị bắt đầu (``start``), giá trị kết thúc (``stop``), bước nhảy (``step_size`` tùy chọn, mặc định là 1):

Hàm ``linspace`` cũng tương tự, nhưng thay vì dùng bước nhảy, hàm này tạo chuỗi dựa trên số lượng lấy mẫu ở giữa.
"""

f = np.arange(10,50,5)   # tạo array của một chuỗi bắt đầu từ 10 đến DƯỚI 50, bước nhảy 5
print(f)

"""**LƯU Ý**: Array ở trên kết thúc tại 45, không phải 50."""

g = np.linspace(0., 1., num=11)
print(g)

"""Nếu ta muốn khởi tạo array bằng cách "chồng" (“stacking”) các array cho trước, theo chiều ngang / dọc. Ta có thể sử dụng các phương thức `vstack()` (hoặc `row_stack`) và `hstack()` (hoặc `column_stack`)."""

a = np.array([1, 2, 3])
b = np.array([4, 5, 6])
np.vstack((a,b))

a = np.array([[7], [8], [9]])
b = np.array([[4], [5], [6]])
print(a)
print(b)
np.hstack((a,b))

"""### 2. Array indexing

Numpy hỗ trợ một số cách chỉ mục để truy cập các phần tử trong array.

Ta có thể chỉ mục (slide) hoặc cắt lát (slice) numpy array giống như kiểu ``list`` trong Python:

![](http://jalammar.github.io/images/numpy/numpy-array-slice.png)

Ta có thể thực hiện chỉ mục hoặc cắt lát trên nhiều chiều khác nhau của array:

![](http://jalammar.github.io/images/numpy/numpy-matrix-indexing.png)
"""

# Tạo ma trận 2 chiều với kích thước (3, 4)
# [[ 1  2  3  4]
#  [ 5  6  7  8]
#  [ 9 10 11 12]]
a = np.array([[1,2,3,4], [5,6,7,8], [9,10,11,12]])
print('Array "a" gốc:')
print(a)
# Cắt lát mảng con từ 2 dòng đầu tiên
# và cột với chỉ mục 1 và 2;
# array `b` sau khi cắt lát có kích thước (2, 2):
# [[2 3]
#  [6 7]]

b = a[:2, 1:3]
print(b)

"""Lát cắt của một array bản chất vẫn tham chiếu lên cùng dữ liệu gốc, do đó ***chỉnh sửa trên lát cắt cũng sẽ thay đổi nội dung của dữ liệu gốc****."""

print(a[0, 1])
b[0, 0] = 77    # b[0, 0] cùng tham chiếu đến dữ liệu của a[0, 1]
print(a[0, 1])

print('"a" sau khi được thay đổi giá trị bởi tham chiếu b: ')
print(a)

"""Chú ý, trong một số trường hợp có thể **làm giảm chiều của array** khi tạo lát cắt:"""

# Khởi tạo array 2 chiều kích thước (3, 4)
a = np.array([[1,2,3,4], [5,6,7,8], [9,10,11,12]])
print(a)

"""Nếu sử dụng *chỉ mục là một số nguyên*, chiều của lát cắt **bị giảm**.

Nếu sử dụng *chỉ mục dạng lát cắt*, chiều của lát cắt **giữ nguyên** so với dữ liệu gốc.
"""

row_r1 = a[1, :]    # Cùng nội dung là dòng thứ 2, chiều của array chỉ còn 1
row_r2 = a[1:2, :]  # Cùng nội dung là dòng thứ 2, chiều của array vẫn là 2
row_r3 = a[[1], :]  # Cùng nội dung là dòng thứ 2, chiều của array vẫn là 2
print(row_r1, row_r1.shape)
print(row_r2, row_r2.shape)
print(row_r3, row_r3.shape)

# Tương tự như vậy khi thực hiện trên cột
col_r1 = a[:, 1]
col_r2 = a[:, 1:2]
print(col_r1, col_r1.shape)
print()
print(col_r2, col_r2.shape)

"""*Chỉ mục là mảng số nguyên* (Integer array indexing): thay vì sử dụng chỉ mục dạng lát cắt, ta có thể tạo array từ các phần từ bất kỳ trong array gốc:"""

a = np.array([[1,2], [3, 4], [5, 6]])
print('"a" gốc: ')
print(a)
print("\n")
# Ví dụ về chỉ mục dạng mảng số nguyên.
# Kết quả trả về là array 1 chiều với 3 phần tử: shape=(3,)
print(a[[0, 1, 2], [0, 1, 0]])

# Kết quả trên tương đương với:
print(np.array([a[0, 0], a[1, 1], a[2, 0]]))

"""*Bài tập*: Bạn thử đoán xem kết quả in ra màn hình sau khi thực hiện cắt lát array"""

# Khởi tạo array 2 chiều kích thước (4,3)
a = np.array([[1,2,3], [4,5,6], [7,8,9], [10, 11, 12]])
a

# Tạo array chỉ mục
b = np.array([0, 2, 0, 1])

# Mỗi dòng lấy một phần tử, tại các cột có chỉ mục `b`
print(a[np.arange(4), b])  # [0  1  2  3]  [0, 2, 0, 1]

# Cùng tăng 10 đơn vị cho mỗi phần tử của mỗi dòng, tại các cột có chỉ mục `b`
a[np.arange(4), b] += 10
print(a)

"""*Chỉ mục là mảng Boolean* (Boolean array indexing): Cho phép lấy ra các phần tử bất kỳ trong array gốc. Thông thường, phương pháp này thường để lấy các phần tử thỏa mãn tính chất nào đó:"""

import numpy as np

a = np.array([[1,2], [3, 4], [5, 6]])

bool_idx = (a > 2)  # Tìm các phần tử lớn hơn 2;
                    # lệnh này trả về boolean array có kích thước giống với `a`
                    # trong đó, tại mỗi vị trí của bool_idx cho biết có thỏa mãn
                    # tính chất phần tử của a đó lớn hơn 2 không.

print(bool_idx)

# Sử dụng chỉ mục với boolean array để tạo một array 1 chiều
# chứa các phần tử tương ứng với các phần tử nhận giá trị True trên bool_idx
print(a[bool_idx])

# Ta có thể viết gọn lại:
print(a[a > 2])

"""Khi làm việc với các numpy array, ta có thể cần phải trả về chỉ mục *indices* (không chỉ giá trị) của các phần tử trong array thỏa mãn một tính chất nào đó. Có một số hàm phổ biến như sau:

-   [`argmax`](https://numpy.org/doc/stable/reference/generated/numpy.argmax.html) (lấy chỉ số của phần tử lớn nhất)
-   [`argmin`](https://numpy.org/doc/stable/reference/generated/numpy.argmin.html) (lấy chỉ số của phần tử nhỏ nhất)
-   [`argsort`](https://numpy.org/doc/stable/reference/generated/numpy.argsort.html) (lấy chỉ số của các phần tử sau khi đã sắp xếp, theo thứ tự tăng dần)
-   [`where`](https://numpy.org/doc/stable/reference/generated/numpy.where.html) (lấy chỉ số của các phần tử thỏa một một điều kiện nào đó)
"""

a = np.array([1, 8, 9, -3, 2, 4, 7, 9])

# Lấy chỉ số của phần tử lớn nhất trong `a`
print(np.argmax(a))

# Lấy chỉ số của phần tử nhỏ nhất trong `a`
# chỉ trả về một chỉ số, nếu có nhiều hơn 1 giá trị nhỏ nhất
print(np.argmin(a))

# Lấy chỉ số của các phần tử sau khi sắp xếp tăng dần theo giá trị
print(np.argsort(a))

# Lấy chỉ số của các phần tử sau khi sắp xếp giảm dần theo giá trị
# [::-1] là cách lấy chỉ mục lát cắt theo thứ tự nghịch đảo
print(np.argsort(a)[::-1])

# Lấy chỉ mục của các phần tử thỏa mãn tính chất nào đó
# Trả về một tuple, với danh sách chỉ mục là phần tử đầu tiên
# sử dụng [0] để lấy danh sách chỉ mục này
print(np.where(a > 5)[0])

# Lấy chỉ mục của các phần tử thỏa mãn tính chất nào đó
# Lấy chỉ mục của TẤT CẢ phần tử lớn nhất trong mảng
print(np.where(a >= a[np.argmax(a)])[0])

"""### 3. Các kiểu dữ liệu của Array (Datatype)

Numpy array là một cấu trúc các phần tử có cùng kiểu dữ liệu. Numpy array hỗ trợ nhiều KDL khác nhau. Numpy cố gắng đoán KDL khi ta khởi tạo array mà không khai báo tường minh KDL của là gì:
"""

x = np.array([1, 2])  # Để numpy tự chọn KDL
y = np.array([1.0, 2.0])  # Để numpy tự chọn KDL
z = np.array([1, 2], dtype=np.int64)  # Chỉ định một KDL cho trước

print(x.dtype, y.dtype, z.dtype)

"""### 4. Array math

Điều khiến `numpy` trở nên nổi tiếng chính là: sự tiện lợi và hiệu năng cao. Tiện lợi do có thể thực hiện được các hàm toán học vector hóa (vectorized) để tính toán trên các phần tử của một array. Các hàm được tối ưu hóa và có tốc độ thực thi nhanh hơn vòng lặp `for` rất nhiều lần.

Ví dụ, ta có thể thực hiện phép cộng hai array ngẫu nhiên, sử dụng `%%time` để đo thời gian thực thi:
"""

a = np.random.random(100000000)

# Commented out IPython magic to ensure Python compatibility.
# %%time
# x = np.sum(a)

# Commented out IPython magic to ensure Python compatibility.
# %%time
# x = 0
# for element in a:
#   x = x + element

"""Việc tối ưu tốc độ như vậy rất phù hợp với các thuật toán máy học, vốn sử dụng rất nhiều các phép tính toán.

Bất cứ khi nào có thể, **cố gắng sử dụng các phép toán vector hóa**.

Một số hàm toán học có ở cả dạng toán tử và hàm trong numpy.

Ví dụ, ta có thể thực hiện phép tổng theo từng phần tử của hai array bằng cách sử dụng operator + hoặc hàm `add()`.

![](http://jalammar.github.io/images/numpy/numpy-arrays-adding-1.png)

![](http://jalammar.github.io/images/numpy/numpy-matrix-arithmetic.png)
"""

x = np.array([[1,2],[3,4]], dtype=np.float64)
y = np.array([[5,6],[7,8]], dtype=np.float64)

# Tổng theo từng phần tử, thực hiện bằng 2 cách
print(x + y)
print(np.add(x, y))

"""Không chỉ phép cộng, điều này cũng tương tự cho các toán tử khác:

![](http://jalammar.github.io/images/numpy/numpy-array-subtract-multiply-divide.png)
"""

# Hiệu theo từng phần tử, thực hiện bằng 2 cách
print(x - y)
print(np.subtract(x, y))

# Tích theo từng phần tử (element wise product), thực hiện bằng 2 cách
print(x * y)
print(np.multiply(x, y))

# Chia theo từng phần tử, thực hiện bằng 2 cách
# [[ 0.2         0.33333333]
#  [ 0.42857143  0.5       ]]
print(x / y)
print(np.divide(x, y))

# Lấy căn theo từng phần tử, thực hiện bằng 2 cách
# [[ 1.          1.41421356]
#  [ 1.73205081  2.        ]]
print(np.sqrt(x))

"""Chú ý, `*` là tích theo từng phần tử, không phải nhân 2 ma trận. Do đó, ta sử dụng hàm `dot()` để tính tích của các vector, vector - ma trận, ma trận - ma trận. `dot()` vừa ở dạng hàm của numpy, vừa là một phương thức của array:

![](http://jalammar.github.io/images/numpy/numpy-matrix-dot-product-1.png)
"""

x = np.array([[1,2],[3,4]])
y = np.array([[5,6],[7,8]])

v = np.array([9,10])
w = np.array([11, 12])

# Inner product of vectors; both produce 219
print(v.dot(w))
print(np.dot(v, w))

"""Ta có thể sử dụng toán tử `@` tương đương với toán tử `dot`."""

print(v @ w)

# Hai cách để nhân ma trận - vector,
# cả hai đều tạo array 1 chiều là [29 67]
print(x.dot(v))
print(np.dot(x, v))
print(x @ v)

# Hai cách để nhân ma trận - vector,
# cả hai đều tạo array 2 chiều:
# [[19 22]
#  [43 50]]
print(x.dot(y))
print(np.dot(x, y))
print(x @ y)

"""Bên cạnh các toán tử, ``numpy`` còn hỗ trợ các hàm tính toán trên array như: `min()`, `max()`, `sum()`,...:

![](http://jalammar.github.io/images/numpy/numpy-matrix-aggregation-1.png)
"""

x = np.array([[1, 2], [3, 4], [5, 6]])

print(np.max(x))  # Tính giá trị lớn nhất của các phần tử;
print(np.min(x))  # Tính giá trị nhỏ nhất của các phần tử;
print(np.sum(x))  # Tính tổng tất cả các phần tử;

"""Không chỉ có thể tính toán trên toàn bộ phần tử của ma trận, các hàm trên còn có thể thực hiện theo từng hàng hoặc từng cột bằng cách sử dụng tham số `axis`:

![](http://jalammar.github.io/images/numpy/numpy-matrix-aggregation-4.png)
"""

x = np.array([[1, 2], [5, 3], [4, 6]])
print('"x" gốc: ')
print(x)
print(np.max(x, axis=0))  # Tính max trên mỗi cột
print(np.max(x, axis=1))  # Tính max trên mỗi dòng

"""Danh sách các hàm được numpy hỗ trợ có thể tham khảo ở đây: [documentation](http://docs.scipy.org/doc/numpy/reference/routines.math.html).

Bên cạnh các hàm toán học trên array, ta còn thường có nhu cầu thay đổi kích thước trên array. Thao tác đơn giản nhất chính là chuyển vị. Để chuyển vị ma trận, ta sử dụng thuộc tính `.T` của một đối tượng array.

![](http://jalammar.github.io/images/numpy/numpy-transpose.png)
"""

x = np.array([[1, 2], [3, 4], [5, 6]])

print(x)
print("transpose\n", x.T)

v = np.array([[1,2,3]])
print(v )
print("transpose\n", v.T)

"""Trong nhiều tình huống, ta cần phải thay đổi chiều của một ma trận. Đặc biệt là trong lĩnh vực máy học, đây là thao tác rất phổ biến. Phương thức `reshape()` của numpy giúp chúng ta giải quyết vấn đề này.

![](http://jalammar.github.io/images/numpy/numpy-reshape.png)

Ví dụ: ta có thể chuyển array 1 chiều thành array 2 chiều, và ngược lại với với phương thức `reshape()`. Trong thực tế, ta có thể chuyển đổi ảnh 2D array thành một dạng vector đặc trưng 1D array.
"""

w = np.array([[1],[2],[3]])
print(w)
w.shape

"""Ta có thể loại bỏ các tham số "không cần thiết" để đưa về dạng array 1 chiều với tham số -1. Khi đó phương thức sẽ tự tính toán kích thước của ma trận nguồn để chuyển sang array 1 chiều (vector đích)."""

y = w.reshape(-1,)
print(y)
y.shape

"""Tương tự như vậy cho hàm `squeeze()`:"""

z = w.squeeze()
print(z)
z.shape

"""Để chuyển từ dạng 1D sang 2D array, ta có thể thêm vào một chiều nữa với kích thước là 1 (bên cạnh một chiều kích thước -1, hàm ý numpy tự tính kích thước cho chiều này):"""

y.reshape((-1,1))

"""### Broadcasting

Broadcasting: là cơ chế hiệu quả cho phép numpy có thể làm việc với các array với các kích thước khác nhau khi thực hiện các phép toán.

Ví dụ: trong đại số tuyến tính, ta chỉ có thể thực hiện phép cộng (tương tự cho các toán tử thực hiện theo từng phần tử - element-wise) hai ma trận có cùng số chiều và kích thước. Trong numpy, nếu ta muốn cộng hai trận có số chiều khác nhau, numpy sẽ **ngầm mở rộng** số chiều của một ma trận để cả hai ma trận có thể thực hiện tính toán được. Khi đó phép toán sẽ thực hiện được mà không báo lỗi:

![](https://sebastianraschka.com/images/blog/2020/numpy-intro/broadcasting-1.png)

![](https://sebastianraschka.com/images/blog/2020/numpy-intro/broadcasting-2.png)

Broadcasting hai array với nhau tuân theo các quy tắc sau:

**Quy tắc 1**: Nếu **hai array khác số chiều**, kích thước của array với số chiều (dimension) ít hơn sẽ được chèn thêm 1 về phía đầu bên trái.

Ví dụ sau, array `a` sẽ được ngầm mở rộng shape từ (3,) thành shape (1,3):
"""

a = np.array([1,2,3])         # shape (3,): 1 chiều, sẽ ngầm mở rộng -> 2 chiều, shape(1,3)
b = np.array([[4], [5], [6]]) # shape (3,1): 2 chiều
c = a + b                     # kết quả sẽ là shape (3,3) (2 chiều).
                              # Lưu ý, kết quả này còn phải vận dụng thêm Quy tắc 2
print(c)

"""**Quy tắc 2**: Nếu shape của hai array không khớp nhau ở một chiều nào đó, array nào có kích thước chiều bằng 1 sẽ được **kéo dài** ở chiều đó để khớp với array còn lại.

Ví dụ sau, array `a` sẽ được ngầm mở rộng từ shape (3,1) shape (3,2):
"""

a = np.array([[1],[2],[3]])         # shape (3,1), sẽ ngầm kéo dài thành (3,2) để khớp với b
# --> [1, 1]
#     [2, 2]
#     [3, 3]
b = np.array([[4,5], [6,7], [8,9]]) # shape (3,2)

c = a + b                           # kích thước (3,2)
print(c)

"""**Quy tắc 3**: Nếu hai array không có chiều nào bằng nhau và không có chiều nào kích thước bằng 1 thì báo lỗi.

"""

a = np.array([[1],[2],[3],[4]])      # shape (4,1)
b = np.array([[4,5], [6,7], [8,9]])  # shape (3,2)
c = a + b                            # ValueError: operands could not be broadcast

"""Chi tiết có thể xem thêm ở đây [documentation](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html).

Sau đây là một số ví dụ về broadcasting.

![](http://jalammar.github.io/images/numpy/numpy-array-broadcast.png)

Chú ý rằng, các array tương thích theo từng chiều nếu kích thước giống nhau cho từng chiều hoặc có một array nào đó có kích thước một chiều nào đó bằng 1.


![](http://jalammar.github.io/images/numpy/numpy-matrix-broadcast.png)

# PHẦN 2: LẬP TRÌNH VỚI MATPLOTLIB

Matplotlib là một thư viện để trực quan hoá bằng cách vẽ các dữ liệu kết quả tính toán. Trong phần này ta sẽ chỉ tập trung vào module quan trọng nhất là `matplotlib.pyplot`.

Theo thông lệ, ta thường khai báo thư module này với tên viết tắt là `plt`:
"""

import matplotlib.pyplot as plt

"""### 1. Plotting

Hàm quan trọng nhất trong `matplotlib` là `plot`, cho phép vẽ dữ liệu 2D dưới dạng các đường thẳng. Ví dụ:
"""

# Khởi tạo x và y là các toạ độ điểm trên đường cong hình sine
x = np.arange(0, 3 * np.pi, 0.1)
y = np.sin(x)

# vẽ các điểm này với matplotlib
plt.plot(x, y)

# Hiển thị kết quả
plt.show()

"""Ta có thể vẽ nhiều đường thẳng cùng lúc, thêm các tiêu đề, chú thích, và ghi chú trên từng trục dữ liệu:"""

y_sin = np.sin(x)
y_cos = np.cos(x)

# Vẽ các điểm với matplotlib
plt.plot(x, y_sin, label='Sine')
plt.plot(x, y_cos, label='Cosine')
plt.legend() # sử dụng tham số `label` ở trên để chú thích

plt.xlabel('x axis label')
plt.ylabel('y axis label')
plt.title('Sine and Cosine')

# Hiển thị kết quả
plt.show()

"""Một cách thức vẽ khác là `scatter`:"""

x = np.random.rand(50)
y = np.random.rand(50)
colors = np.random.randint(0, 2, 50)

plt.scatter(x, y, c=colors)

plt.show()

"""Khi các điểm dữ liệu không có sự liên kết giữa các điểm (về mặt logic như: chuỗi thời gian, chuỗi thứ tự) thì ta không vẽ dưới dạng đường mà dùng `scatter`.

### 2.Subplots

Nếu ta muốn vẽ nhiều hình khác nhau một lúc, ta sử dụng hàm `subplot`. Ví dụ:
"""

# Khởi tạo toạ độ các điểm x và y theo đường cong hình sine và cosine
x = np.arange(0, 3 * np.pi, 0.1)
y_sin = np.sin(x)
y_cos = np.cos(x)

# Tạo lưới subplot với chiều cao là 2 và chiều rộng là 1,
# sau đó kích hoạt ô đầu tiên để vẽ
# 2 hàng, 1 cột --> thực hiện vẽ trên ô đầu tiên (ô số 1)
plt.subplot(2, 1, 1)

# Vẽ lên ô đầu tiên
plt.plot(x, y_sin)
plt.title('Sine')

# Kích hoạt ô thứ hai, sau đó vẽ lên ô này
plt.subplot(2, 1, 2)
# 2 hàng, 1 cột --> thực hiện vẽ trên ô thứ 2
plt.plot(x, y_cos)
plt.title('Cosine')

# Điều chỉnh khoảng cách giữa các ô
plt.subplots_adjust(hspace = 0.4)

# Hiển thị kết quả
plt.show()

"""Tham khảo chi tiết thêm ở đây [documentation](http://matplotlib.org/api/pyplot_api.html#matplotlib.pyplot.subplot).

### 3. Chart types
"""

t = np.arange(0.0, 2.0, 0.05)
s = np.sin(2*np.pi*t)

# Scater
plt.subplot(221)
plt.scatter(t,s, marker=">")

# Lines
plt.subplot(222)
plt.plot(t,s)

# Bar chart
plt.subplot(223)
x = np.arange(3)
money = [1.5e5, 2.5e6, 5.5e6]
plt.bar(x, money)
plt.xticks(x, ("Cty A", "Cty B", "Cty C"))

# Pie chart
plt.subplot(224)
labels = "Other", "China", "USA"
sizes = [25, 35, 40]
plt.pie(sizes, labels=labels)
plt.show()

"""### 4. Đọc, hiển thị ảnh

Để có thể hiển thị hình ảnh từ file, ta sử dụng hàm `imshow`. Ví dụ:
"""

from matplotlib.cbook import get_sample_data

img_file = get_sample_data('grace_hopper.jpg')

img = plt.imread(img_file)
plt.imshow(img)
plt.show()

"""Toàn bộ của `pyplot` ta có thể tham khảo thêm ở đây [documentation](http://matplotlib.org/api/pyplot_api.html) to learn more.

# PHẦN 3: LẬP TRÌNH VỚI PANDAS
Ta có thể tham khảo cheat sheet (bảng tóm tắt) các thao tác phổ biến trên Pandas: https://pandas.pydata.org/Pandas_Cheat_Sheet.pdf
"""

import pandas as pd

"""## 1. Tạo một bảng với DataFrame"""

df = pd.DataFrame({
    "a" : [4, 5, 6],
    "b" : [7, 8, 9],
    "c" : [10, 11, 12]},
    index = [1, 2, 3])
df

"""## 2. Truy xuất cột, dòng"""

df[['b']]

"""## 3. Xóa một cột, dòng

## 4. Nối và reshape bảng
"""

df1 = pd.DataFrame({
    "a" : [9, 10, 11],
    "b" : [12, 13, 14],
    "c" : [15, 16, 17]})
df2 = pd.DataFrame({
    "a" : [1, 2, 3],
    "b" : [4, 5, 6],
    "c" : [7, 8, 8]},)
pd.concat((df1, df2), axis=0)

df1 = pd.DataFrame({
    "X" : [9, 10, 11],
    "Y" : [12, 13, 14],
    "Z" : [15, 16, 17]})
df2 = pd.DataFrame({
    "a" : [1, 2, 3],
    "b" : [4, 5, 6],
    "c" : [7, 8, 8]},)
pd.concat((df1, df2), axis=1)



"""## 5. Tạo mới cột, dòng

## 4. Gom nhóm

## 5. Vẽ biểu đồ
"""

